#!/usr/bin/env node

// https://github.com/foreverjs/forever/issues/918

var fs = require('fs');
var execSync = require('child_process').execSync;
var path = require('path');

var action = process.argv[ 2 ];
var p1 = process.argv[ 3 ];
var p2 = process.argv[ 4 ];

var cmd = 'naps';

var usage = `
Usage:
    ${cmd} help
    This help screen

    ${cmd} config
    Display all of the config entries

    ${cmd} config write
    Write the expanded nginx config onto the CONF file

    ${cmd} startable
    List all apps that can be started

    ${cmd} started
    List all apps currently running under forever (considering all possible uid/gid pairs)

    ${cmd} startall
    Start all apps that can be started

    ${cmd} stopall
    Stop all apps

    ${cmd} start <app-name>
    Start a specific app using forever

    ${cmd} stop <app-name>
    Start a specific app using forever
    
`;

if( !action ){
  console.log( usage );
  process.exit(1);
}


var Generator = function( inputConfPath ){
  this.ip = '';
  this.dir = '/var/';
  this.portMap = {};
  this.confLines = [];
  this.startableHash = {};
  this.uidGidHash = {};
  this.outputConfFile = '';

  try {
    var inputConf = fs.readFileSync( inputConfPath );
  } catch( e ){
    console.log("Could not open config file:", e );
    process.exit(2);
  }

  inputConf.toString().split(/\n/).forEach( ( confLineStr ) => {


    // It's a comment
    if( confLineStr.match(/\s*\#/) || confLineStr.match(/^\s*$/) ) return;

    // Parse it. Lose the original value -- it doesn't matter
    var confLine = confLineStr.match(/\S+/g);

    // Add the line to confLines
    this.confLines.push( confLine );

    // Add item to startableHash and uidGidHash
    if( confLine[ 0 ] == "RUN" ){
      if( this.startableHash[ confLine[ 1 ] ] ){
        console.log("Duplicate appName as RUN:", confLine[ 1 ] );
        process.exit( 6 );
      }

      this.startableHash[ confLine[ 1 ] ] = confLine;

      // Yes they can be duplicated, and definitely will be
      this.uidGidHash[ confLine[ 4 ] ] = confLine;
    }

  });


  this.confLines.forEach( (confLine ) => {
    var method = confLine[ 0 ];

    if( ! this.configGeneratorMethods[ method ] ){
      console.log("Unrecognised method:", method );
      process.exit( 3 );
    }

    this.outputConfFile += this.configGeneratorMethods[ method ].apply( this, confLine.slice( 1 ) );
  });

};
Generator.prototype = {

  configGeneratorMethods: {

    DIR: function( dir ){
      this.dir = dir; 
      return '';
    },
 
    CONF: function( conf ){
      this.conf = conf; 
      return '';
    },
 
    RUN: function(appName, port ){
      this.portMap[ appName ] = port; 
      return '';
    },
  

    SET_IP: function( ip ){
      this.ip = ip;
      return '';
    },

    REDIRECT_HTTP_TO_HTTPS: function( fromHost, toHost ){
      var ip = this.ip;
      return `
  
        # REDIRECT_HTTP_TO_HTTPS, ${fromHost}, ${toHost}
  
        server {
            listen       ${ip}:80;
            server_name ${fromHost};
            return 301 https:\/\/${toHost}\$request_uri;
        }
      `;
    },
  
    PROXY_HTTP_TO_LOCAL_PORT: function( host, appName ){
      var ip = this.ip;
      var port = this.portMap[ appName ];
      return `
  
        # PROXY_HTTP_TO_LOCAL_PORT, ${host}, ${port}
  
        server {
            listen ${ip}:80 http2;
            server_name ${host};
  
            client_max_body_size 0;
  
            location / {
  
              proxy_pass http:\/\/localhost:${port};
              #proxy_http_version 1.1;
              proxy_set_header Upgrade $http_upgrade;
              proxy_set_header Connection 'upgrade';
              proxy_set_header Host $host;
              proxy_cache_bypass $http_upgrade;
            }
        }
  
      `;
    },
  
  
    PROXY_HTTPS_TO_LOCAL_PORT: function( host, appName ){
      var ip = this.ip;
      var port = this.portMap[ appName ];
      return `
  
        # PROXY_HTTPS_TO_LOCAL_PORT, ${host}, ${port}
  
        server {
            listen ${ip}:443 ssl http2;
            server_name ${host};
  
            client_max_body_size 0;
  
            ssl_certificate /etc/nginx/ssl/${host}.crt;
            ssl_dhparam /etc/nginx/ssl/dhparam.pem;
            ssl_certificate_key /etc/nginx/ssl/${host}.key;
  
            location / {
  
              proxy_pass http:\/\/localhost:${port};
              #proxy_http_version 1.1;
              proxy_set_header Upgrade $http_upgrade;
              proxy_set_header Connection 'upgrade';
              proxy_set_header Host $host;
              proxy_cache_bypass $http_upgrade;
            }
        }
  
      `;
    },
  
    REDIRECT_BOTH_TO_HTTPS: function( fromHost, toHost ){
      var ip = this.ip;
      return `
  
        # REDIRECT_BOTH_TO_HTTPS, ${fromHost}, ${toHost}
  
        server {
            listen       ${ip}:80;
            server_name ${fromHost};
            return 301 https:\/\/${toHost}\$request_uri;
        }
  
        server {
            listen       ${ip}:443 ssl;
            server_name ${fromHost};

            ssl_certificate /etc/nginx/ssl/${fromHost}.crt;
            ssl_dhparam /etc/nginx/ssl/dhparam.pem;
            ssl_certificate_key /etc/nginx/ssl/${fromHost}.key;


            return 301 https:\/\/${toHost}\$request_uri;
        }
      `;
    },
  },


  _generateConfigFile: function(){

    if( !this.conf ){
      console.log("CONF directive needed to generate config file" );
      process.exit( 7 );
    }

    try {
      fs.writeFileSync( this.conf, this.outputConfFile );
      console.log("\nNginx config file written as: ", this.conf );
    } catch( e ){
      console.log("Could not write output config file: ", e );
      process.exit(8);
    }

  },

  start: function( confLine ){
    console.log("RUNNING:", confLine );

    var env = {
      NODE_ENV: confLine[ 3 ], //production
      APPNAME: confLine[ 1 ], // gigsnet
      DBHOST: 'localhost',
      DBNAME: confLine[ 1 ], // gigsnet
      IPADDRESS: 'localhost',
      PORT: confLine[ 2 ], // 8080
      SERVER: 'server.js',
      HOME: '/home/forever',
    };

    if( confLine[ 5 ] ){
      try {
        var extraEnv = JSON.parse( confLine[ 5 ] );
      } catch( e ){
        console.log("Error parsing extra env for " + confLine[ 1 ] + ": ", e );
        process.exit(9);
      }
      for( var k in extraEnv ){
        env[ k ] = extraEnv[ k ];
      }
    }

    // Work out gid and uid
    var uidGid = confLine[ 4 ].split( /:/ );
    var uid = Number( uidGid[ 0 ] );
    var gid = Number( uidGid[ 1 ] );
   
    // Work out cwd
    var cwd = path.join( this.dir, env.APPNAME );

    var extraForeverSwitch = "";
    if( env.NODE_ENV == 'development' ){
      var extraForeverSwitch ="--watch --watchDirectory " + cwd;
    }       

    var lp = env.APPNAME;
    var server = env.SERVER;
    var appName = env.APPNAME;
    var foreverCommand = `/usr/bin/forever start --uid ${appName} -a ${extraForeverSwitch} -l /var/log/forever/${lp}-forever.log -o /var/log/forever/${lp}-out.log -e /var/log/forever/${lp}-err.log ${server}`;

    console.log("Starting " + confLine[ 1 ] + " in directory", cwd, "with gid and uid", gid, uid, "and with env:\nForever command:\n", foreverCommand, "\nEnvironment:", env );
    
    console.log("SEE:", uid, gid );
    try {
      execSync( foreverCommand, { env: env, uid: uid, gid: gid, cwd: cwd } );
    } catch( e ){
      console.log("Could not execute command:", e );
      process.exit(9);
    }

    // Make up extra watch parameter for development
    // Start forever command, assigning LP as id in forever
  },

  stop: function( confLine, silent ){
    console.log("Stopping forever processes for ", confLine[ 0 ], " as gis/uid" + confLine[ 4 ]  );

     var env = {
      HOME: '/home/forever',
    };

    var appName = confLine[ 1 ];

    // Work out gid and uid
    var uidGid = confLine[ 4 ].split( /:/ );
    var uid = Number( uidGid[ 0 ] );
    var gid = Number( uidGid[ 1 ] );
 
    // Work out command
    var foreverCommand = `forever stop ${appName}`;

    if( silent ){
      try {
        execSync( foreverCommand, { uid: uid, gid: gid, env: env } );
      } catch( e ){
        console.log("Could not stop service, probably wasn't running");
      }
    } else {

      try {
        execSync( foreverCommand, { uid: uid, gid: gid, env: env } );
      } catch( e ){
        console.log("Could not execute command:", e );
        process.exit(9);
      }
    }
  },


  listForever: function( uidGidString ){
    console.log("Forever processes startning under gis/uid", uidGidString );

     var env = {
      HOME: '/home/forever',
    };

    // Work out gid and uid
    var uidGid = uidGidString.split( /:/ );
    var uid = Number( uidGid[ 0 ] );
    var gid = Number( uidGid[ 1 ] );
 
    // Work out command
    var foreverCommand = `forever list`;

    try {
      var res = execSync( foreverCommand, { uid: uid, gid: gid, env: env } );
    } catch( e ){
      console.log("Could not execute command:", e );
      process.exit(9);
    }
    console.log( res.toString() );
    
  }

};
Generator.constructur = Generator;


// Read the config file
var generator = new Generator('/etc/naps.conf');


switch( action ){

  

  case 'started':
    for( var uidGid in generator.uidGidHash ){
      generator.listForever( uidGid );
    }
  break;

  case 'startable':

    // Show list of startable server, showing command, port and 
    generator.confLines.forEach( (confLine) => {
      if( confLine[ 0 ] == 'RUN' ){
        console.log( confLine[ 1 ] + ' (' + confLine[ 2 ] + ') [' + confLine[ 3 ]  + '] running as ' + confLine[ 4 ] );
      }
    });
  break;


  case 'config':

    if( p1 && ( p1 != 'write' ) ){
      console.log("Usage: configurer.js list [write]");
      process.exit(1);
    }

    // Show the full config
    generator.confLines.forEach( (confLine) => {
      console.log( confLine.join(' '));
    });

    // Write the config file if so requested
    if( p1 == 'write' ){
      generator._generateConfigFile();
    }
  break;

  case 'start':
  case 'stop':
   
    if( !p1 ){
      console.log( usage );
      process.exit( 5 );
    }
 
    var confLine = generator.startableHash[ p1 ];
    if( !confLine ){
      console.log("Startable server not found:", p1 );
      console.log( "Use the 'list startable' parameters for the list of startable apps" );
      process.exit( 5 );
    } else {
      if( action == 'start' ){
        generator.stop( confLine, true );
        generator.start( confLine );
      } else {
        generator.stop( confLine );
      }
    }

  break;

  case 'startall':
  case 'stopall':

    Object.keys( generator.startableHash ).forEach( (appName ) => {
      var confLine = generator.startableHash[ appName ];

      if( action == 'startall' ){
        generator.stop( confLine, true );
        generator.start( confLine );
      } else {
        generator.stop( confLine );
      }
    });    

  break;

  case 'config':
  break;

  default:
    console.log( usage );
    process.exit( 3 );
  break;
}
